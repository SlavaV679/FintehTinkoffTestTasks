9 задание
Ограничение времени
1 секунда
Ограничение памяти
256 МБ
Даня в обеденный перерыв ходит в одно и то же кафе. Ему, как сотруднику банка, положено специальное предложение: 
при каждой покупке больше, чем на 100 рублей, Даня получает купон на бесплатный обед.
Даня узнал стоимость своих обедов на ближайшие 𝑛 дней. Ему хочется минимизировать свои затраты, грамотно используя талоны. 
Требуется найти минимальные суммарные затраты Дани на обеды.

Формат входных данных
В первой строке дается натуральное число n(0≤n≤100). В каждой из n строк записана стоимость обеда 
в каждой из дней (неотрицательное целое число, не больше, чем 300).

Формат выходных данных 
В первой строке выдайте минимально возможную суммарную стоимость обедов.

Замечание 
В первом примере Дане придется купить первые 3 обеда, после чего у него появится талон. 
Этот талон будет выгоднее всего потратить на последний обед. Таким образом, он купит первые 4 обеда и получит пятый бесплатный.

Примеры данных

Ввод
5 
35 
40 
101 
59 
63
 
Вывод
235



Я сам не смог решить эту задачку. В телеграмме нашел Константин Осипов (https://t.me/osipov_ko),
который через минут 10 после моего вопроса дал ответ:
Константин Осипов, [7/12/2024 1:16 PM]
Да, задача интересная. Я думал в лоб решать. Но похоже это динамическое программирование (recursion with memoization или tabulation), 
ограничения по входных данным (до 100 элементов) разрешают его использовать

Tabulation обычно сложнее реализовать, чем рекурсию с мемоизацией. Но это по сути одно и то же в плане быстродействия. 
Tabulation чуть быстрее работает (если это критично для задания), потому что не нужно использовать стек очереди в отличие от рекурсии. 
Мемоизация в рекурсии обязательна, так как значительно ускоряет алгоритм (вместо временной сложности O(2^n) получаем O(n))

Константин Осипов, [7/12/2024 1:17 PM]
Бектрекинг для таких входных данных не подходит, для него максимум 20-30 элементов должно быть во входных данных

и еще через часок дал решение.

Я его не понял, хоть и продебажил,
начал читать теорию.
Вот эту статью осилил: https://www.geeksforgeeks.org/tabulation-vs-memoization/

Тут как раз они сопоставляют табуляцию с мемоизацией.

В качестве примера показывают сначала на числах Фибоначи, потом на расчете факториала.

Вопросы есть к обоим методам, рассмотрим расчет факториала:

В обоих случаях они создают массив 
int dp[MAXN]

В случае табуляции они его заполняют bottom-up и в итоге у них есть массив с этими числами.

В случае с мемоизацией, этот же массив они сначала заполняют значениями "-1",
а потом его заполняют методом top-down то есть с помощью рекурсии вычисленными данными.

И В ЧЕМ тут МЕМОИЗАЦИЯ????

As we can see we are storing the most recent cache up to a limit so that if next time we got a call from the same state 
we simply return it from the memory. So, this is why we call it memoization as we are storing the most recent state values. 
In this case, the memory layout is linear that’s why it may seem that the memory is being filled in a sequential manner like the tabulation method, 
but you may consider any other top-down DP having 2D memory layout like Min Cost Path, here the memory is not filled in a sequential manner.

В первом случае тоже будет тот же массив с данными, он тоже в памяти.
